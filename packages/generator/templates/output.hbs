/**
 * The extracted data from your controllers and configurations for this template hydration. 
 * In case you need some metadata at runtime, this is the place to look.
 */
export const KitaAST = {{json this}};

{{#if hasAsync}}  
  /**
   * The filename to be used when creating a Piscina instance.
   * 
   * @example
   * import { filename } from './routes';
   * const piscina = new Piscina({ filename });
   */
  export const filename = __filename;

  //@ts-ignore - Piscina may not be available because no async route was found.
  if (require('piscina')?.isWorkerThread) {
    {{#each routes}}
      {{#if async}}
        let {{controllerName}}: Record<string, Function>;

        module.exports.{{operationId}} = async (args: any[]) => {
          // lazy loads {{controllerName}}.
          if (!{{controllerName}}) {
            {{controllerName}} = require('{{importablePath}}');
          }

          return {{controllerName}}.{{controllerMethod}}!.apply(undefined, args);
        };
      {{/if}}
    {{/each}}

    //@ts-expect-error - NodeJS modules are wrapped into a function, so this return will work.
    return;
  }
{{/if}}

import type { RouteContext, ProvidedRouteContext } from '@kitajs/runtime';
import fp from 'fastify-plugin';
import '@fastify/swagger';
{{#each imports}}
  {{this}}
{{/each}}

/**
 * This is the resolved config that was used during code generation. JIC its needed at runtime.
 */
export const config = {{json config}};

/**
 * The Kita generated fastify plugin. Registering it into your fastify instance will
 * automatically register all routes, schemas and controllers.
 *
 * @example
 * ```ts
 * import { Kita } from './routes'; // this file
 * import app from './fastify-app';
 * 
 * app.register(Kita, { context: { ... } })
 * ```
 */
export const Kita = fp<{ context: ProvidedRouteContext }>((fastify, options) => {
  const context: RouteContext = { config, fastify, ...options.context };

  {{#each schemas}}
    fastify.addSchema({{jsonf this}});

  {{/each}}

  {{#each routes}}
    {{rendered}}

  {{/each}}

  // Ensure this function remains a "async" function
  return Promise.resolve();
});
